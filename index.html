<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Daily Crypto Mentions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --maxw: 1100px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color: #111; }
    header { max-width: var(--maxw); margin: 0 auto 16px; }
    h1 { margin: 0 0 8px; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin: 8px 0 16px; }
    select { padding: 6px 8px; font-size: 14px; }
    .muted { color: #666; font-size: 12px; }
    .link { margin: 6px 0 12px; }
    main { max-width: var(--maxw); margin: 0 auto; display: grid; grid-template-columns: 1fr; gap: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f7f7f7; }
    caption { text-align: left; font-weight: 600; margin-bottom: 8px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
    @media (min-width: 900px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }
    canvas { width: 100%; height: 420px; }
  </style>
</head>
<body>
  <header>
    <h1>Daily Crypto Mentions</h1>
    <div class="controls">
      <label for="date-select">Select date:</label>
      <select id="date-select" aria-label="Select date"></select>

      <label for="topn-select">Top N:</label>
      <select id="topn-select" aria-label="Select number of lines">
        <option value="5">5</option>
        <option value="10">10</option>
        <option value="20" selected>20</option>
      </select>

      <span id="meta" class="muted"></span>
    </div>
    <div id="thread-link" class="link"></div>
  </header>

  <main>
    <div class="grid">
      <section>
        <table>
          <caption>Top coins by mentions (selected day)</caption>
          <thead>
            <tr><th style="width:80px">Symbol</th><th>Name</th><th style="width:120px">Mentions</th></tr>
          </thead>
          <tbody id="data-table"><tr><td colspan="3">Loadingâ€¦</td></tr></tbody>
        </table>
      </section>
      <section>
        <canvas id="mentions-chart"></canvas>
      </section>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
  (function() {
    'use strict';

    const manifestUrl = 'manifest.json';
    const selectEl = document.getElementById('date-select');
    const topNEl = document.getElementById('topn-select');
    const tbody = document.getElementById('data-table');
    const metaEl = document.getElementById('meta');
    const threadLinkEl = document.getElementById('thread-link');
    const ctx = document.getElementById('mentions-chart').getContext('2d');

    let manifestData = [];
    let chartInstance = null;

    // Fetch JSON with cache-busting
    async function fetchJson(url) {
      const res = await fetch(url + (url.includes('?') ? '&' : '?') + 'v=' + Date.now(), { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status + ' for ' + url);
      return res.json();
    }

    // Normalize a day's data into a sorted list [{symbol, name, count}]
    function normalizeDayList(dayData) {
      let list = [];
      if (Array.isArray(dayData.results_list) && dayData.results_list.length) {
        list = dayData.results_list.map(r => ({
          symbol: (r.symbol || '').toUpperCase(),
          name: r.name || '',
          count: Number(r.count || 0)
        }));
      } else if (dayData.results && typeof dayData.results === 'object') {
        list = Object.entries(dayData.results).map(([k, v]) => ({
          symbol: (k || '').toUpperCase(),
          name: '',
          count: Number(v || 0)
        }));
      }
      list.sort((a, b) => b.count - a.count);
      return list;
    }

    function renderTable(list, limit = 100) {
      const rows = list.slice(0, limit).map(row => (
        `<tr><td>${row.symbol}</td><td>${row.name || ''}</td><td>${row.count}</td></tr>`
      )).join('');
      tbody.innerHTML = rows || '<tr><td colspan="3">No data</td></tr>';
    }

    function getPalette(n) {
      const base = [
        '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
        '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
        '#4e79a7','#f28e2b','#e15759','#76b7b2','#59a14f',
        '#edc948','#b07aa1','#ff9da7','#9c755f','#bab0ab'
      ];
      const out = [];
      for (let i = 0; i < n; i++) out.push(base[i % base.length]);
      return out;
    }

    async function loadDayData(filePath, topN) {
      try {
        const dayData = await fetchJson(filePath);
        const list = normalizeDayList(dayData);

        // Thread link + meta
        const updated = dayData.generated_at_utc ? new Date(dayData.generated_at_utc).toISOString().replace('T',' ').replace('Z',' UTC') : '';
        threadLinkEl.innerHTML = dayData.thread_url
          ? `<a href="${dayData.thread_url}" target="_blank" rel="noopener">${dayData.thread_title || 'Thread link'}</a>`
          : (dayData.thread_title || '');
        metaEl.textContent = updated ? `Updated ${updated}` : '';

        // Table
        renderTable(list, 100);

        // Chart for historical trend of the top N symbols from the selected day
        const focusSymbols = list.slice(0, topN).map(r => r.symbol);
        await renderChartUpToDate(filePath, focusSymbols);
      } catch (e) {
        tbody.innerHTML = `<tr><td colspan="3">Error loading ${filePath}: ${e}</td></tr>`;
        if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
      }
    }

    async function renderChartUpToDate(filePath, focusSymbols) {
      const selectedIndex = manifestData.findIndex(m => m.file === filePath);
      if (selectedIndex < 0) {
        if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
        return;
      }
      const filteredManifest = manifestData.slice(0, selectedIndex + 1); // from start up to selected date
      const dates = filteredManifest.map(m => m.date);

      // Build data arrays for each focus symbol
      const series = {};
      focusSymbols.forEach(sym => series[sym] = []);
      for (const entry of filteredManifest) {
        const day = await fetchJson(entry.file);
        const list = normalizeDayList(day);
        const map = {};
        list.forEach(r => { map[r.symbol] = r.count; });
        focusSymbols.forEach(sym => {
          series[sym].push(map[sym] || 0);
        });
      }

      // Create datasets
      const colors = getPalette(focusSymbols.length);
      const datasets = focusSymbols.map((sym, i) => ({
        label: sym,
        data: series[sym],
        borderColor: colors[i],
        backgroundColor: colors[i],
        borderWidth: 2,
        pointRadius: 1.5,
        fill: false,
        tension: 0.15
      }));

      if (chartInstance) chartInstance.destroy();
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          animation: false,
          plugins: {
            legend: {
              position: 'right',
              labels: { boxWidth: 12, usePointStyle: true }
            },
            title: { display: true, text: `Mentions over time (top ${focusSymbols.length} of selected day)` },
            tooltip: { mode: 'index', intersect: false }
          },
          interaction: { mode: 'nearest', axis: 'x', intersect: false },
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'Mentions' } },
            x: { title: { display: true, text: 'Date' } }
          }
        }
      });
    }

    // Init: load manifest, populate dropdown, load latest
    (async function init() {
      try {
        const raw = await fetchJson(manifestUrl);
        // Ensure sorted by date ascending, and de-duplicate by date (keep last)
        const byDate = new Map();
        raw.forEach(item => { byDate.set(item.date, item); });
        manifestData = Array.from(byDate.values()).sort((a, b) => a.date.localeCompare(b.date));

        // Populate dates
        selectEl.innerHTML = '';
        manifestData.forEach(entry => {
          const opt = document.createElement('option');
          opt.value = entry.file;
          opt.textContent = entry.date;
          selectEl.appendChild(opt);
        });
        if (!manifestData.length) {
          tbody.innerHTML = '<tr><td colspan="3">No manifest data found</td></tr>';
          return;
        }

        // Load latest with default topN
        const currentFile = manifestData[manifestData.length - 1].file;
        selectEl.value = currentFile;
        await loadDayData(currentFile, parseInt(topNEl.value, 10));

        // React to changes
        selectEl.addEventListener('change', () => {
          loadDayData(selectEl.value, parseInt(topNEl.value, 10));
        });
        topNEl.addEventListener('change', () => {
          loadDayData(selectEl.value, parseInt(topNEl.value, 10));
        });
      } catch (e) {
        tbody.innerHTML = `<tr><td colspan="3">Error loading manifest: ${e}</td></tr>`;
      }
    })();
  })();
  </script>
</body>
</html>
