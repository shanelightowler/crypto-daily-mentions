<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Daily Crypto Mentions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --maxw: 1100px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color: #111; }
    header { max-width: var(--maxw); margin: 0 auto 16px; }
    h1 { margin: 0 0 8px; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin: 8px 0 16px; }
    select, input[type="text"] { padding: 6px 8px; font-size: 14px; }
    .muted { color: #666; font-size: 12px; }
    .link { margin: 6px 0 12px; }
    main { max-width: var(--maxw); margin: 0 auto; display: grid; grid-template-columns: 1fr; gap: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f7f7f7; }
    caption { text-align: left; font-weight: 600; margin-bottom: 8px; }

    /* Stack sections; we will place ETH panel above the table */
    .grid { display: grid; grid-template-columns: 1fr; gap: 20px; }

    /* Chart sizing: approximately half-panel height on desktop, smaller on mobile */
    .chart-container { width: 100%; height: 400px; }
    @media (max-width: 900px) {
      .chart-container { height: 300px; }
    }
    /* Let Chart.js use the container height */
    .chart-container canvas { width: 100% !important; height: 100% !important; }

    /* ETH predictions panel styles */
    .eth-panel { border: 1px solid #ddd; border-radius: 6px; padding: 12px; background: #fafafa; }
    .eth-panel h2 { margin: 0 0 8px; font-size: 18px; }
    .eth-panel .row { display: flex; flex-wrap: wrap; gap: 16px; }
    .eth-panel .card { flex: 1 1 280px; border: 1px solid #e6e6e6; border-radius: 6px; padding: 10px; background: #fff; }
    .eth-panel .label { color: #666; font-size: 12px; text-transform: uppercase; letter-spacing: .02em; }
    .eth-panel .value { font-weight: 600; margin-top: 2px; }
    .eth-panel .small { color: #666; font-size: 12px; margin-top: 6px; }
    .eth-panel a { color: #1f6feb; text-decoration: none; }
    .eth-panel a:hover { text-decoration: underline; }

    /* Pikaday CSS (minimal to look decent) */
    .pika-single { z-index: 9999; display: block; position: relative; color: #333; background: #fff; border: 1px solid #ccc; box-shadow: 0 1px 3px #bbb; border-radius: 3px; }
    .pika-single.is-hidden { display: none; }
    .pika-lendar { padding: 10px; }
    .pika-title { text-align: center; position: relative; margin-bottom: 10px; user-select: none; }
    .pika-label { font-weight: 700; font-size: 14px; }
    .pika-prev, .pika-next { cursor: pointer; position: absolute; top: 14px; width: 20px; height: 20px; line-height: 20px; text-align: center; font-size: 18px; color: #999; user-select: none; }
    .pika-prev:hover, .pika-next:hover { color: #000; }
    .pika-prev { left: 10px; }
    ..pika-next { right: 10px; }
    .pika-table { width: 100%; border-collapse: collapse; border-spacing: 0; user-select: none; }
    .pika-table th, .pika-table td { width: 14.2857142857%; padding: 5px 0; text-align: center; cursor: pointer; }
    .pika-table th { color: #999; font-weight: 700; font-size: 12px; }
    .pika-button { border: none; background: none; color: inherit; font: inherit; cursor: pointer; outline: none; }
    .is-disabled { color: #ccc !important; pointer-events: none; cursor: default; }
    .is-selected { background: #1f77b4; color: white; border-radius: 3px; }
    .is-today { color: #d33; font-weight: 700; }
  </style>
</head>
<body>
  <header>
    <h1>Daily Crypto Mentions</h1>
    <div class="controls">
      <label for="date-picker">Select date:</label>
      <input type="text" id="date-picker" aria-label="Select date" readonly />
      <label for="topn-select">Top N:</label>
      <select id="topn-select" aria-label="Select number of lines">
        <option value="5">5</option>
        <option value="10">10</option>
        <option value="20" selected>20</option>
      </select>
      <span id="meta" class="muted"></span>
    </div>
    <div id="thread-link" class="link"></div>
  </header>
  <main>
    <div class="grid">
      <!-- NEW: ETH predictions panel appears above the table -->
      <section class="eth-panel" id="eth-panel">
        <h2>ETH Bull‑Run Top Predictions</h2>
        <div class="row">
          <div class="card">
            <div class="label">Consensus (last 30 days)</div>
            <div class="value" id="eth-consensus-main">—</div>
            <div class="small" id="eth-consensus-sub">—</div>
          </div>
          <div class="card">
            <div class="label">Selected day summary</div>
            <div class="value" id="eth-day-main">—</div>
            <div class="small" id="eth-day-sub">—</div>
            <div class="small" id="eth-day-link"></div>
          </div>
        </div>
      </section>

      <section>
        <table>
          <caption>Top coins by mentions (selected day)</caption>
          <thead>
            <tr>
              <th style="width:80px">Symbol</th>
              <th>Name</th>
              <th style="width:120px">Mentions</th>
              <th style="width:120px">% change</th>
            </tr>
          </thead>
          <tbody id="data-table"><tr><td colspan="4">Loading…</td></tr></tbody>
        </table>
      </section>
      <section>
        <div class="chart-container">
          <canvas id="mentions-chart"></canvas>
        </div>
      </section>
    </div>
  </main>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pikaday/pikaday.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css" />
  <script>
  (function() {
    'use strict';
    // Endpoints and elements
    const manifestUrl = 'manifest.json';
    const predsManifestUrl = 'predictions_manifest.json';
    const consensusUrl = 'predictions/consensus.json';

    const datePickerEl = document.getElementById('date-picker');
    const topNEl = document.getElementById('topn-select');
    const tbody = document.getElementById('data-table');
    const metaEl = document.getElementById('meta');
    const threadLinkEl = document.getElementById('thread-link');
    const ctx = document.getElementById('mentions-chart').getContext('2d');

    // ETH panel elements
    const ethConsensusMainEl = document.getElementById('eth-consensus-main');
    const ethConsensusSubEl  = document.getElementById('eth-consensus-sub');
    const ethDayMainEl       = document.getElementById('eth-day-main');
    const ethDaySubEl        = document.getElementById('eth-day-sub');
    const ethDayLinkEl       = document.getElementById('eth-day-link');

    // App state
    let manifestData = [];
    let dateToFileMap = {};
    let validDateStrs = [];
    let picker = null;
    let chartInstance = null;

    // ETH predictions state
    let predsManifestData = [];
    let predsDateToFileMap = {};
    let consensusData = null;

    // -------- URL state helpers (unique URL per day) --------
    function parseUrlState() {
      const p = new URLSearchParams(location.search);
      const date = (p.get('date') || '').trim();
      const top = parseInt(p.get('top') || '', 10);
      return {
        date: date || null,
        top: Number.isFinite(top) ? top : null
      };
    }
    function setUrlState(date, top, { replace = false } = {}) {
      const url = new URL(location.href);
      if (date) url.searchParams.set('date', date); else url.searchParams.delete('date');
      if (top) url.searchParams.set('top', String(top)); else url.searchParams.delete('top');
      if (replace) history.replaceState({}, '', url.toString());
      else history.pushState({}, '', url.toString());
    }
    window.addEventListener('popstate', () => {
      const { date, top } = parseUrlState();
      const targetDate = (date && validDateStrs.includes(date)) ? date : validDateStrs[validDateStrs.length - 1];
      const targetTop = validateTop(top ?? parseInt(topNEl.value, 10));
      setPickerDate(targetDate);
      topNEl.value = String(targetTop);
      const file = dateToFileMap[targetDate];
      if (file) loadDayData(file, targetTop, targetDate);
    });
    function validateTop(n) {
      const allowed = [5, 10, 20];
      return allowed.includes(n) ? n : 20;
    }
    function setPickerDate(iso) {
      if (!picker || !iso) return;
      const [y, m, d] = iso.split('-').map(Number);
      picker.setDate(new Date(y, m - 1, d), true);
      datePickerEl.value = iso;
    }
    // --------------------------------------------------------
    // Deterministic, consistent colors per symbol
    const COLOR_MAP = {
      BTC:'#F2A900', ETH:'#627EEA', BNB:'#F3BA2F', SOL:'#14F195', ADA:'#0033AD',
      XRP:'#23292F', DOGE:'#C2A633', TRX:'#EF0027', TON:'#0098EA', AVAX:'#E84142',
      DOT:'#E6007A', MATIC:'#8247E5', LTC:'#345C9C', BCH:'#8DC351', XLM:'#14B6E7',
      SHIB:'#F00500', LINK:'#2A5ADA', ATOM:'#2E3148', ETC:'#3CB073', XMR:'#FF6600',
      FIL:'#0090FF', ICP:'#29ABE2', APT:'#13B5EC', SUI:'#6FBCF0', ARB:'#28A0F0',
      OP:'#FF0420', INJ:'#00D1FF', NEAR:'#111827', ALGO:'#1E1E1E', HBAR:'#3E9AD9',
      AAVE:'#B6509E', UNI:'#FF007A', LDO:'#00A3FF', RPL:'#F9703E', MKR:'#1ABC9C',
      COMP:'#00D395', SNX:'#00D1C1', CRV:'#406AFF', CVX:'#3D3D3D', GMX:'#2D55FF',
      DYDX:'#6966FF', IMX:'#0A93FF', SAND:'#00ADEF', MANA:'#FF2D55', APE:'#0054F0',
      GRT:'#6F4C9B', FET:'#00B6B1', RNDR:'#FF4D00', KAS:'#0047FF', TIA:'#7C4DFF',
      SEI:'#FF3B3B', PEPE:'#4CAF50', FLOKI:'#F5A623', BONK:'#FFC04D', WIF:'#4DD0E1',
      JUP:'#00E5FF', PYTH:'#6C5CE7', JTO:'#00C2A8', STRK:'#2D2D2D', BLUR:'#FF6A1A',
      CHZ:'#CD1125', ENJ:'#624DBF', ZRX:'#222222', BAT:'#FF5000', ZEC:'#ECB244',
      DASH:'#008CE3', KAVA:'#FF564F', KDA:'#2B2E83', KSM:'#434343', ROSE:'#8E54E9',
      RUNE:'#2A5B84', EGLD:'#0C6CF2', NEO:'#58BF00', GALA:'#111111', SFP:'#2BB673',
      CAKE:'#FE6E95', STX:'#5546FF', MINA:'#90CAF9', AR:'#FF3D00', ASTR:'#FF46A1',
      OSMO:'#6F42C1', SKL:'#00C7B7', CFX:'#FCD535', XDC:'#1E5DF2', TFUEL:'#F7931A',
      THETA:'#2AB8E6', BTT:'#ED1C24', OKB:'#1F5AFF', HT:'#2E74B5', CRO:'#002D72',
      QNT:'#F2C94C', RSR:'#141414', NEXO:'#1A4B84'
    };
    const FALLBACK_PALETTE = [
      '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
      '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
      '#4e79a7','#f28e2b','#e15759','#76b7b2','#59a14f',
      '#edc948','#b07aa1','#ff9da7','#9c755f','#bab0ab',
      '#2b908f','#f45b5b','#91e8e1','#7cb5ec','#434348'
    ];
    function hashSymbol(sym) {
      let h = 0;
      for (let i = 0; i < sym.length; i++) h = (h * 31 + sym.charCodeAt(i)) >>> 0;
      return h;
    }
    function colorForSymbol(sym) {
      if (COLOR_MAP[sym]) return COLOR_MAP[sym];
      const idx = hashSymbol(sym) % FALLBACK_PALETTE.length;
      return FALLBACK_PALETTE[idx];
    }
    // Fetch JSON with cache-busting
    async function fetchJson(url) {
      const res = await fetch(url + (url.includes('?') ? '&' : '?') + 'v=' + Date.now(), { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status + ' for ' + url);
      return res.json();
    }
    // USD formatting
    const usd0 = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 });
    function fmtUSD(n) {
      if (n === null || n === undefined) return '—';
      return usd0.format(n);
    }

    // Normalize a day's data into a sorted list [{symbol, name, count}]
    function normalizeDayList(dayData) {
      let list = [];
      if (Array.isArray(dayData.results_list) && dayData.results_list.length) {
        list = dayData.results_list.map(r => ({
          symbol: (r.symbol || '').toUpperCase(),
          name: r.name || '',
          count: Number(r.count || 0)
        }));
      } else if (dayData.results && typeof dayData.results === 'object') {
        list = Object.entries(dayData.results).map(([k, v]) => ({
          symbol: (k || '').toUpperCase(),
          name: '',
          count: Number(v || 0)
        }));
      }
      list.sort((a, b) => b.count - a.count);
      return list;
    }
    function formatPctChange(curr, prev) {
      if (prev === null) return '—';
      if (prev === 0) return curr > 0 ? 'new' : '—';
      const pct = ((curr - prev) / prev) * 100;
      const rounded = Math.round(pct);
      const sign = rounded > 0 ? '+' : '';
      return `${sign}${rounded}%`;
    }
    function renderTable(list, limit, prevMap) {
      const rows = list.slice(0, limit).map(row => {
        const prev = prevMap[row.symbol] ?? null;
        const pct = formatPctChange(row.count, prev);
        return `<tr><td>${row.symbol}</td><td>${row.name || ''}</td><td>${row.count}</td><td>${pct}</td></tr>`;
      }).join('');
      tbody.innerHTML = rows || '<tr><td colspan="4">No data</td></tr>';
    }

    // ---------- ETH predictions rendering ----------
    function renderConsensusPanel() {
      if (!consensusData || !consensusData.pooled_predictions) {
        ethConsensusMainEl.textContent = 'No consensus yet';
        ethConsensusSubEl.textContent = '';
        return;
      }
      const pp = consensusData.pooled_predictions;
      const windowDays = consensusData.window_days || 30;
      const n = pp.count || 0;
      const med = fmtUSD(pp.median_usd);
      const avg = fmtUSD(pp.mean_usd);
      ethConsensusMainEl.textContent = (n > 0) ? `Median ${med}` : 'No consensus yet';
      ethConsensusSubEl.textContent = (n > 0) ? `Mean ${avg} • N=${n} • Window ${windowDays}d` : '';
    }

    async function renderEthForDate(selectedDateIso) {
      // Load daily predictions if available
      const file = predsDateToFileMap[selectedDateIso];
      if (!file) {
        ethDayMainEl.textContent = 'No predictions found for this date';
        ethDaySubEl.textContent = '';
        ethDayLinkEl.innerHTML = '';
        return;
      }
      try {
        const data = await fetchJson(file);
        const sum = data.summary || {};
        const n = sum.count || 0;
        const med = fmtUSD(sum.median_usd);
        const avg = fmtUSD(sum.mean_usd);
        const lo = fmtUSD(sum.min_usd);
        const hi = fmtUSD(sum.max_usd);
        ethDayMainEl.textContent = (n > 0) ? `Median ${med}` : 'No predictions found for this date';
        ethDaySubEl.textContent = (n > 0) ? `Mean ${avg} • Range ${lo} – ${hi} • N=${n}` : '';
        if (data.thread_url && data.thread_title) {
          ethDayLinkEl.innerHTML = `<a href="${data.thread_url}" target="_blank" rel="noopener">${data.thread_title}</a>`;
        } else {
          ethDayLinkEl.innerHTML = '';
        }
      } catch (e) {
        ethDayMainEl.textContent = 'Error loading predictions';
        ethDaySubEl.textContent = '';
        ethDayLinkEl.innerHTML = '';
        console.error(e);
      }
    }
    // ------------------------------------------------

    async function loadDayData(filePath, topN, selectedDateIso) {
      try {
        // Current day
        const dayData = await fetchJson(filePath);
        const list = normalizeDayList(dayData);
        // Thread link + meta
        const updated = dayData.generated_at_utc ? new Date(dayData.generated_at_utc).toISOString().replace('T',' ').replace('Z',' UTC') : '';
        threadLinkEl.innerHTML = dayData.thread_url
          ? `<a href="${dayData.thread_url}" target="_blank" rel="noopener">${dayData.thread_title || 'Thread link'}</a>`
          : (dayData.thread_title || '');
        metaEl.textContent = updated ? `Updated ${updated}` : '';
        // Previous day map for % changes
        let prevMap = {};
        const idx = validDateStrs.indexOf(selectedDateIso);
        if (idx > 0) {
          const prevIso = validDateStrs[idx - 1];
          const prevFile = dateToFileMap[prevIso];
          if (prevFile) {
            const prevData = await fetchJson(prevFile);
            const prevList = normalizeDayList(prevData);
            prevMap = Object.fromEntries(prevList.map(r => [r.symbol, r.count]));
          }
        }
        // Table (with % change)
        renderTable(list, 100, prevMap);
        // ETH predictions panel for this date
        await renderEthForDate(selectedDateIso);
        // Chart for historical trend of the top N symbols from the selected day
        const focusSymbols = list.slice(0, topN).map(r => r.symbol);
        await renderChartUpToDate(focusSymbols);
      } catch(e) {
        tbody.innerHTML = `<tr><td colspan="4" style="color:red;">Error loading data</td></tr>`;
        metaEl.textContent = '';
        threadLinkEl.textContent = '';
        console.error(e);
      }
    }

    async function renderChartUpToDate(focusSymbols) {
      // Gather historical data for these symbols from manifest
      const promises = manifestData.map(async d => {
        const dayData = await fetchJson(d.file);
        const normalized = normalizeDayList(dayData);
        const map = {};
        normalized.forEach(r => { map[r.symbol] = r.count; });
        return { date: d.date, map };
      });
      const results = await Promise.all(promises);
      const labels = results.map(r => r.date);
      const datasets = focusSymbols.map(sym => {
        const color = colorForSymbol(sym);
        return {
          label: sym,
          data: results.map(r => r.map[sym] || 0),
          fill: false,
          borderColor: color,
          backgroundColor: color,
          tension: 0.1,
          pointRadius: 2,
          borderWidth: 2,
          spanGaps: true
        };
      });
      if (chartInstance) chartInstance.destroy();
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,  // respect container (.chart-container) height
          interaction: { mode: 'nearest', intersect: false },
          plugins: {
            legend: { position: 'top' },
            tooltip: {
              enabled: true,
              mode: 'index',
              intersect: false,
              callbacks: {
                title: ctx => ctx[0].label,
                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}`,
              }
            }
          },
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'Mentions' } },
            x: { title: { display: true, text: 'Date' } }
          }
        }
      });
    }

    // Format date as local YYYY-MM-DD (no timezone shift)
    function formatLocalDate(d) {
      const y = d.getFullYear();
      const m = (d.getMonth() + 1).toString().padStart(2, '0');
      const day = d.getDate().toString().padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    // Initialize picker with valid dates only
    function setupDatePicker() {
      picker = new Pikaday({
        field: datePickerEl,
        format: 'YYYY-MM-DD',
        firstDay: 1,
        toString(date) { return formatLocalDate(date); },
        disableDayFn(date) {
          const iso = formatLocalDate(date);
          return !validDateStrs.includes(iso);
        },
        onSelect(date) {
          const iso = formatLocalDate(date);
          const top = parseInt(topNEl.value, 10);
          const file = dateToFileMap[iso];
          if (file) {
            setUrlState(iso, top, { replace: false });
            loadDayData(file, top, iso);
          }
        }
      });
    }

    async function init() {
      try {
        // Load manifests (crypto + predictions) and consensus
        const [cryptoMan, predsMan, cons] = await Promise.all([
          fetchJson(manifestUrl),
          (async () => { try { return await fetchJson(predsManifestUrl); } catch { return []; } })(),
          (async () => { try { return await fetchJson(consensusUrl); } catch { return null; } })()
        ]);

        // Crypto manifest
        manifestData = Array.isArray(cryptoMan) ? cryptoMan.slice() : [];
        manifestData.sort((a, b) => a.date.localeCompare(b.date));
        dateToFileMap = {};
        validDateStrs = [];
        manifestData.forEach(d => {
          if (d.date && d.file) {
            dateToFileMap[d.date] = d.file;
            validDateStrs.push(d.date);
          }
        });

        // Predictions manifest
        predsManifestData = Array.isArray(predsMan) ? predsMan.slice() : [];
        predsDateToFileMap = {};
        predsManifestData.forEach(d => {
          if (d.date && d.file) predsDateToFileMap[d.date] = d.file;
        });

        // Consensus
        consensusData = cons;
        renderConsensusPanel();

        // Setup date picker
        setupDatePicker();

        // Determine initial state from URL or default to latest date
        const urlState = parseUrlState();
        const latestDate = validDateStrs[validDateStrs.length - 1] || null;
        const initialDate = (urlState.date && validDateStrs.includes(urlState.date)) ? urlState.date : latestDate;
        const initialTop = validateTop(urlState.top ?? parseInt(topNEl.value, 10));

        // Reflect initial state in UI
        topNEl.value = String(initialTop);
        if (initialDate) {
          setPickerDate(initialDate);
          setUrlState(initialDate, initialTop, { replace: true });
          const file = dateToFileMap[initialDate];
          if (file) loadDayData(file, initialTop, initialDate);
        } else {
          tbody.innerHTML = '<tr><td colspan="4">No manifest data found</td></tr>';
        }
      } catch(e) {
        tbody.innerHTML = `<tr><td colspan="4" style="color:red;">Failed to load manifest</td></tr>`;
        console.error(e);
      }
    }

    // React to Top N changes (keep date, update URL and reload)
    topNEl.addEventListener('change', () => {
      if (!picker) return;
      const date = picker.getDate();
      if (!date) return;
      const iso = formatLocalDate(date);
      const file = dateToFileMap[iso];
      const top = validateTop(parseInt(topNEl.value, 10));
      if (file) {
        setUrlState(iso, top, { replace: false });
        loadDayData(file, top, iso);
      }
    });

    // Go!
    init();
  })();
  </script>
</body>
</html>
